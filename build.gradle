// First, apply the publishing plugin
buildscript {
  repositories {
    maven {
      url "https://plugins.gradle.org/m2/"
    }
      mavenCentral()
  }
  dependencies {
    classpath "com.gradle.publish:plugin-publish-plugin:1.3.1"
    classpath 'com.netflix.nebula:gradle-extra-configurations-plugin:10.0.1'
  }
}

plugins {
  id 'groovy'
  id 'idea'
  alias(libs.plugins.axion.release)
  alias(libs.plugins.plugin.publish)
  id 'java-gradle-plugin'
  alias(libs.plugins.animalsniffer)
  alias(libs.plugins.version.catalog.update)
  alias(libs.plugins.versions)
}

apply plugin: 'cloud.rio.license'

defaultTasks 'build'

group = 'cloud.rio.gradle.plugins'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    maven { url 'https://jitpack.io' }
    mavenCentral()
    google()
}

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}


scmVersion {
    tag {
        prefix = 'v'
        versionSeparator = ''
    }
    hooks {
        pre 'fileUpdate', [file: 'README.adoc', pattern: { v, c -> /:license_plugin_version .*/}, replacement: { v, c -> ":license_plugin_version: $v" }]
        pre 'commit'
    }
}

project.version = scmVersion.version


configurations.implementation.transitive = false

sourceSets.create("integrationTest")

dependencies {
  signature 'org.codehaus.mojo.signature:java17:1.0@signature'

    implementation libs.plexus.utils
    implementation libs.xmltool
    implementation(libs.license.maven.plugin) {
        exclude group: 'org.apache.maven', module: 'maven-plugin-api'
        exclude group: 'org.apache.maven', module: 'maven-project'
    }
    implementation gradleApi()

    testImplementation libs.android.gradle.plugin

    integrationTestImplementation(project)
    integrationTestImplementation gradleTestKit()
    integrationTestImplementation platform(libs.spock.bom)
    integrationTestImplementation libs.nebula.test
    integrationTestImplementation libs.spock.core
    integrationTestImplementation libs.spock.junit4
    integrationTestImplementation libs.junit
    integrationTestImplementation libs.junit.platform.launcher
    integrationTestImplementation libs.guava

    testImplementation gradleTestKit()
    testImplementation libs.nebula.test
    testImplementation platform(libs.spock.bom)
    testImplementation libs.spock.core
    testImplementation libs.spock.junit4
    testImplementation libs.junit
    testImplementation libs.guava
}

def integrationTestTask = tasks.register("integrationTest", Test) {
    description = 'Runs the integration tests.'
    group = "verification"
    testClassesDirs = sourceSets.integrationTest.output.classesDirs

    classpath = sourceSets.integrationTest.runtimeClasspath + sourceSets.main.output + configurations.testRuntimeClasspath

    mustRunAfter(tasks.named('test'))
    useJUnitPlatform()
}

tasks.named('check') {
    it.dependsOn(integrationTestTask)
}


// This disables the pedantic doclint feature of JDK8
if (JavaVersion.current().isJava8Compatible()) {
    tasks.withType(Javadoc).configureEach {
        options.addStringOption('Xdoclint:none', '-quiet')
    }
}

task sourcesJar(type: Jar) {
    from sourceSets.main.allSource
    archiveClassifier = 'sources'
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    archiveClassifier = 'javadoc'
    from javadoc.destinationDir
}

license {
    ignoreFailures true
}

tasks.withType(Test).configureEach { t ->
  t.afterSuite { descriptor, result ->
    def indicator = "\u001B[32m✓\u001b[0m"
    if (result.failedTestCount > 0) {
      indicator = "\u001B[31m✘\u001b[0m"
    }
    logger.lifecycle("$indicator Test ${descriptor.name}; Executed: ${result.testCount}/\u001B[32m${result.successfulTestCount}\u001B[0m/\u001B[31m${result.failedTestCount}\u001B[0m")
  }
}

gradlePlugin {
    website = "https://github.com/rio-cloud/license-gradle-plugin"
    vcsUrl = "https://github.com/rio-cloud/license-gradle-plugin"
    plugins {
        licensePlugin {
            id = "cloud.rio.license"
            implementationClass = "nl.javadude.gradle.plugins.license.LicensePlugin"
            displayName = "License plugin for Gradle"
            description = "Forked from hierynomus/license-gradle-plugin. Applies a header to files, typically a license"
            tags.set(['dependency-management', 'license', 'reporting', 'gradle9', 'compliance'])
            
        }
        licenseBasePlugin {
            id = "cloud.rio.license-base"
            implementationClass = "com.hierynomus.gradle.license.LicenseBasePlugin"
            displayName = "Base License plugin for Gradle"
            description = "Forked from hierynomus/license-gradle-plugin. Base plugin to apply a header to files, typically a license"
            tags.set(['dependency-management', 'license', 'reporting', 'gradle9', 'compliance'])
        }
        licenseReportPlugin {
            id = "cloud.rio.license-report"
            implementationClass = "com.hierynomus.gradle.license.LicenseReportingPlugin"
            displayName = "License Report plugin for Gradle"
            description = "Forked from hierynomus/license-gradle-plugin. Reports over licenses"
            tags.set(['dependency-management', 'license', 'reporting', 'gradle9', 'compliance'])
        }
    }
}

publishing {
    publications {
        pluginMaven(MavenPublication) {
            pom {
                name = project.name
                description = project.description
                url = "https://github.com/rio-cloud/license-gradle-plugin"
                inceptionYear = '2011'
                scm {
                    url = "https://github.com/rio-cloud/license-gradle-plugin.git"
                }
                licenses {
                    license {
                        name = 'The Apache Software License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        distribution = 'repo'
                    }
                }
                developers {
                    developer {
                        id = 'hierynomus'
                        name = 'Jeroen van Erp'
                        url = 'http://www.javadude.nl/'
                        email = 'jeroen@javadude.nl'
                        roles = ['Developer']
                    }
                }
                contributors {
                    contributor {
                        name = 'Tim Harsch'
                        email = 'harschware@yahoo.com'
                    }
                    contributor {
                        name = 'Justin Ryan'
                        email = 'jryan@netflix.com'
                    }
                    contributor {
                        name = 'Veselin Nikolov'
                        email = 'nickolov.vesselin@gmail.com'
                    }
                }
            }
        }
    }
}

versionCatalogUpdate {
    versionSelector {
        // here 'it' is a ModuleVersionCandidate that can be used to determine if the version
        // is allowed, returning true if it is.
        !(it.candidate.version.contains('SNAPSHOT') || it.candidate.version.contains('ALPHA'))
    }
}

//if (!System.env.containsKey("JENKINS_URL")) {
//    def javaVersion = System.properties['java.version']
//    if (JavaVersion.toVersion(javaVersion) != project.targetCompatibility) {
////        throw new GradleException("Expected Java version ${project.targetCompatibility} but running with $javaVersion")
//    }
//}
